<p class="text-center">
    <img src="https://raw.githubusercontent.com/hjdhjd/homebridge-unifi-protect/main/homebridge-protect.svg"
        alt="homebridge-unifi-protect logo" style="width: 60%;" />
</p>
<div id="pageIntro" style="display: none;">
    <p class="lead text-center">Thank you for installing <strong>homebridge-unifi-protect</strong></p>
    <div class="text-center">
       <button type="button" class="btn btn-primary" id="introLink">Continue &rarr;</button>
    </div>
 </div>
<div id="menuWrapper" class="btn-group w-100 mb-0" role="group" aria-label="UI Menu" style="display: none;">
    <button type="button" class="btn btn-primary" id="menuSettings">
        Main Settings
    </button>
    <button type="button" class="btn btn-primary" id="menuProtect">
        Feature Options
    </button>
    <button type="button" class="btn btn-primary mr-0" id="menuHome">
        Support
    </button>
</div>
<div id="disabledBanner" class="alert alert-secondary mb-0 mt-3" role="alert" style="display: none;">
    Plugin is currently disabled
    <button id="disabledEnable" type="button" class="btn btn-link p-0 m-0 float-right">
        Enable
    </button>
</div>
<div id="pageOptions" class="mt-2" style="display: none;">
    <div id="deviceInfo">
        <table class="table table-sm table-borderless">
          <tr class="align-center">
            <td id="headerInfo" colspan="2" class="m-0 p-2 text-center font-weight-bold"></td>
          </tr>
          <tr class="align-top">
            <td rowspan="3" class="w-25">
              <table class="table table-sm table-bordered m-0 p-0">
                <tr>
                  <td>
                    <table class="table table-sm table-borderless m-0 p-0" id="controllersTable">
                    </table>
                  </td>
                </tr>
                <tr>
                  <td>
                    <table class="table table-sm table-borderless m-0 p-0" id="devicesTable">
                    </table>
                  </td>
                </tr>
              </table>
            </td>
            <td>
              <table class="table table-sm table-borderless border-bottom m-0 p-0" id="deviceStatsTable" style="display: none;">
                <tr id="deviceStatsHeader">
                    <th style="width: 30%;" class="m-0 p-0"><B>Model<B></th>
                    <th style="width: 25%;" class="m-0 p-0"><B>IP Address</B></th>
                    <th style="width: 20%;" class="m-0 p-0"><B>MAC Address</B></th>
                    <th style="width: 25%;" class="m-0 p-0"><B>Status</B></th>
                </tr>
                <tr>
                    <td id="device_model" class="m-0 p-0"></td>
                    <td id="device_address" class="m-0 p-0"></td>
                    <td id="device_mac" class="m-0 p-0"></td>
                    <td id="device_online" class="m-0 p-0"></td>
                </tr>
              </table>
            </td>
          </tr>
          <tr>
            <td id="configTable" style="width: 100%;">
            </td>
          </tr>
        </table>
    </div>
</div>
<div id="pageSupport" class="mt-4" style="display: none;">
    <p class="text-center lead">Thank you for using <strong>homebridge-unifi-protect</strong>.</p>

    <p>Other plugins by <a target="_blank" href="https://github.com/hjdhjd">HJD</a>: </p>

    <ul dir="auto">
      <li><a target="_blank" href="https://github.com/hjdhjd/homebridge-myq">homebridge-myQ: Liftmaster and Chamberlain garage door opener support for HomeKit</a></li>
    </ul>

    <p class="text-center lead">Documentation Reference</p>

    <h5>Features</h5>
    <ul dir="auto">
        <li>
            Getting Started
            <ul dir="auto">
                <li>
                    <a target="_blank" href="#installation">Installation</a>
                    : installing this plugin, including system requirements.
                </li>
                <li>
                    <a target="_blank" href="#plugin-configuration">Plugin Configuration</a>
                    : how to quickly get up and running.
                </li>
                <li>
                    <a target="_blank" href="https://github.com/hjdhjd/homebridge-unifi-protect/blob/main/docs/BestPractices.md">Best Practices</a>
                    : best practices for getting the most of your HomeKit setup and UniFi Protect.
                </li>
                <li>
                    <a target="_blank" href="https://github.com/hjdhjd/homebridge-unifi-protect/blob/main/docs/Troubleshooting.md">Troubleshooting</a>
                    : run into login problems or streaming problems? Give this a read.
                </li>
            </ul>
        </li>
        <li>
            Advanced Topics
            <ul dir="auto">
                <li>
                    <a target="_blank" href="https://github.com/hjdhjd/homebridge-unifi-protect/blob/main/docs/Autoconfiguration.md">Autoconfiguration</a>
                    : what it is, design choices that I've made, and why.
                </li>
                <li>
                    <a target="_blank" href="https://github.com/hjdhjd/homebridge-unifi-protect/blob/main/docs/FeatureOptions.md">Feature Options</a>
                    : granular options to allow you to set the camera quality individually, show or hide specific cameras, controllers, and more.
                </li>
                <li>
                    <a target="_blank" href="https://github.com/hjdhjd/homebridge-unifi-protect/blob/main/docs/AudioOptions.md">Audio Options</a>
                    : options to further tailor how audio is handled from Protect, such as background noise reduction.
                </li>
                <li>
                    <a target="_blank" href="https://github.com/hjdhjd/homebridge-unifi-protect/blob/main/docs/Doorbell.md">Doorbells</a>
                    : how UniFi Protect doorbell support works in this plugin, and how to use all the available features including doorbell messages.
                </li>
                <li>
                    <a target="_blank" href="https://github.com/hjdhjd/homebridge-unifi-protect/blob/main/docs/HomeKitSecureVideo.md">HomeKit Secure Video</a>
                    : how HomeKit Secure Video support works in this plugin with UniFi Protect.
                </li>
                <li>
                    <a target="_blank" href="https://github.com/hjdhjd/homebridge-unifi-protect/blob/main/docs/Liveviews.md">Liveview Scenes</a>
                    : use the UniFi Protect liveviews feature (available in the UniFi Protect controller webUI) to create motion-detection scenes.
                </li>
                <li>
                    <a target="_blank" href="https://github.com/hjdhjd/homebridge-unifi-protect/blob/main/docs/MQTT.md">MQTT</a>
                    : how to configure MQTT support.
                </li>
                <li>
                    <a target="_blank" href="https://github.com/hjdhjd/homebridge-unifi-protect/blob/main/docs/AdvancedOptions.md">Advanced Configuration</a>
                    : complete list of configuration options available in this plugin.
                </li>
                <li>
                    <a target="_blank" href="https://github.com/hjdhjd/homebridge-unifi-protect/blob/main/docs/ProtectAPI.md">Realtime API Documentation</a>
                    : documentation of how the Ubiquiti realtime updates API works and how to decode the binary protocol.
                </li>
                <li>
                    <a target="_blank" href="https://github.com/hjdhjd/homebridge-unifi-protect/blob/main/docs/Changelog.md">Changelog</a>
                    : changes and release history of this plugin, starting with v3.0.
                </li>
            </ul>
        </li>
    </ul>

    <h5>Help/About</h5>
    <ul>
        <li>
            <a href="https://discord.gg/QXqfHEW"
                target="_blank">Discord Support Channel</a>
        </li>
        <li>
            <a href="https://github.com/hjdhjd/homebridge-unifi-protect/issues/new/choose"
                target="_blank">Create a Developer Support Request</a>
        </li>
        <li>
            <a href="https://github.com/hjdhjd/homebridge-unifi-protect/blob/main/docs/Changelog.md"
                target="_blank">View the Changelog and Release Notes</a>
        </li>
    </ul>
</div>
<script>
  ;
  (async () => {

    try {

      // Retrieve the current plugin configuration.
      let currentConfig = await homebridge.getPluginConfig();

      // Keep a list of all the feature options and option groups.
      let featureOptionList = {};
      let featureOptionGroups = {};

      // Show an navigation bar at the top of the plugin configuration UI.
      const showIntro = () => {

        const introLink = document.getElementById("introLink");

        introLink.addEventListener("click", () => {

          // Show the beachball while we setup.
          homebridge.showSpinner();

          // Create our UI.
          document.getElementById("pageIntro").style.display = "none";
          document.getElementById("menuWrapper").style.display = "inline-flex";
          showSettings();

          // All done. Let the user interact with us.
          homebridge.hideSpinner();
        });

        document.getElementById("pageIntro").style.display = "block";
      }

      // Our list of Protect controllers.
      const controllerList = [];

      // Show the list of controllers we've configured.
      const showControllers = async () => {

        // Show the beachball while we setup.
        homebridge.showSpinner();
        homebridge.hideSchemaForm();

        // Make sure we have the refreshed configuration.
        currentConfig = await homebridge.getPluginConfig();

        // Create our custom UI.
        document.getElementById("menuHome").classList.remove("btn-elegant");
        document.getElementById("menuHome").classList.add("btn-primary");
        document.getElementById("menuProtect").classList.add("btn-elegant");
        document.getElementById("menuProtect").classList.remove("btn-primary");
        document.getElementById("menuSettings").classList.remove("btn-elegant");
        document.getElementById("menuSettings").classList.add("btn-primary");

        // Hide the legacy UI.
        document.getElementById("pageSupport").style.display = "none";
        document.getElementById("pageOptions").style.display = "block";

        // What we're going to do is display our global options, followed by the list of controllers the user has configured.
        // We pre-select the first controller by default for the user as a starting point.

        // Create the table for the our list of controllers and global options.
        const controllersTable = document.getElementById("controllersTable");

        // Start with a clean slate.
        controllersTable.innerHTML = "";

        // We haven't configured anything yet - we're done.
        if(!currentConfig[0]?.controllers?.length) {

          document.getElementById("headerInfo").innerHTML = "Please configure a UniFi Protect controller to access in the main settings tab before configuring feature options."
          homebridge.hideSpinner();
          return;
        }

        // Initialize our informational header.
        document.getElementById("headerInfo").innerHTML = "Feature options are applied in prioritized order, from global to device-specific options:<br><i class=\"text-warning\">Global options</i> (lowest priority) &rarr; <i class=\"text-success\">Protect controller options</i> &rarr; <i class=\"text-info\">Protect device options</i> (highest priority)"

        // Enumerate our global options.
        const trGlobal = document.createElement("tr");

        // Create the cell for our global options.
        const tdGlobal = document.createElement("td");
        tdGlobal.classList.add("m-0", "p-0");

        // Create our label target.
        const globalLabel = document.createElement("label");

        globalLabel.name = "UFP Global Options";
        globalLabel.appendChild(document.createTextNode("Global Options"));
        globalLabel.style.cursor = "pointer";
        globalLabel.classList.add("mx-0", "py-2", "p-0", "w-100");

        globalLabel.addEventListener("click", event => showDevices(null));

        // Add the global options label.
        tdGlobal.appendChild(globalLabel);
        tdGlobal.style.fontWeight = "bold";

        // Add the global cell to the table.
        trGlobal.appendChild(tdGlobal);

        // Now add it to the overall controllers table.
        controllersTable.appendChild(trGlobal);

        // Add it as another controller, for UI purposes.
        controllerList.push(globalLabel);

        // Create a row for our controllers.
        const trController = document.createElement("tr");

        // Create the cell for our controller category row.
        const tdController = document.createElement("td");
        tdController.classList.add("m-0", "p-0");

        // Add the category name, with appropriate casing.
        tdController.appendChild(document.createTextNode("Protect Controller" + (currentConfig[0].controllers.length > 1 ? "s" : "")));
        tdController.style.fontWeight = "bold";

        // Add the cell to the table row.
        trController.appendChild(tdController);

        // Add the table row to the table.
        controllersTable.appendChild(trController);

        for(const ufpController of currentConfig[0].controllers) {

          // Create a row for this controller.
          const trDevice = document.createElement("tr");
          trDevice.classList.add("m-0", "p-0");

          // Create a cell for our controller.
          const tdDevice = document.createElement("td");
          tdDevice.classList.add("m-0", "p-0" , "w-100");

          const label = document.createElement("label");

          label.name = ufpController.address;
          label.appendChild(document.createTextNode(ufpController.address));
          label.style.cursor = "pointer";
          label.classList.add("mx-2", "my-0", "p-0", "w-100");

          label.addEventListener("click", event => showDevices(ufpController));

          // Add the controller label to our cell.
          tdDevice.appendChild(label);

          // Add the cell to the table row.
          trDevice.appendChild(tdDevice);

          // Add the table row to the table.
          controllersTable.appendChild(trDevice);

          controllerList.push(label);
        }

        // All done. Let the user interact with us.
        homebridge.hideSpinner();
        showDevices(currentConfig[0].controllers[0]);
      };

      // Show the devices attached to a controller.
      const showDevices = async (controller) => {

        // Show the beachball while we setup.
        homebridge.showSpinner();

        // Make sure we highlight the selected controller so the user knows where we are.
        controllerList.map(x => (x.name === (controller ? controller.address : "UFP Global Options")) ?
          x.parentElement.classList.add("bg-info", "text-white") : x.parentElement.classList.remove("bg-info", "text-white"));

        const devicesTable = document.getElementById("devicesTable");
        let ufpDevices = [];

        // If we're not accessing global options, pull a list of devices attached to this controller.
        if(controller) {

          ufpDevices = await homebridge.request("/getDevices", { address: controller.address, password: controller.password, username: controller.username });
        }

        // Couldn't connect to the Protect controller for some reason.
        if(controller && !ufpDevices?.length) {

          devicesTable.innerHTML = "";

          document.getElementById("device_model").innerHTML = "Unable to connect to the Protect controller. Check your settings for this controller in the main settings tab to verify they are correct."
          document.getElementById("device_model").colSpan = 3;
          document.getElementById("device_model").style.fontWeight = "bold";
          document.getElementById("device_model").classList.add("text-center");
          document.getElementById("deviceStatsHeader").style.display = "none";

          document.getElementById("device_mac").innerHTML = "";
          document.getElementById("device_address").innerHTML = "";
          document.getElementById("device_online").innerHTML = "";
          document.getElementById("deviceStatsTable").style.display = "inline-table";

          homebridge.hideSpinner();
          return;
        }

        const modelKeys = [...new Set(ufpDevices.map(x => x.modelKey))];
        const deviceList = [];

        // The first entry returned by getDevices is always the controller.
        const nvr = ufpDevices[0];

        // Start with a clean slate.
        devicesTable.innerHTML = "";

        for(const key of modelKeys) {

          // Get all the devices associated with this device category.
          const devices = ufpDevices.filter(x => x.modelKey === key);

          // If it's a controller, we handle that case differently.
          if((key === "nvr") && devices.length) {

            // Change the name of the controller that we show users once we've connected with the controller.
            controllerList.map(x => (x.name === controller.address) ? x.childNodes[0].nodeValue = devices[0].name : true);
            continue;
          }

          // Create a row for this device category.
          const trCategory = document.createElement("tr");

          // Create the cell for our device category row.
          const tdCategory = document.createElement("td");
          tdCategory.classList.add("m-0", "p-0");

          // Add the category name, with appropriate casing.
          tdCategory.appendChild(document.createTextNode((key === "nvr") ? "Protect Controller" : (key.charAt(0).toUpperCase() + key.slice(1) + "s")));
          tdCategory.style.fontWeight = "bold";

          // Add the cell to the table row.
          trCategory.appendChild(tdCategory);

          // Add the table row to the table.
          devicesTable.appendChild(trCategory);

          for(const device of devices) {

            // Create a row for this device.
            const trDevice = document.createElement("tr");
            trDevice.classList.add("m-0", "p-0");

            // Create a cell for our device.
            const tdDevice = document.createElement("td");
            tdDevice.classList.add("m-0", "p-0" , "w-100");

            const label = document.createElement("label");

            label.name = device.id;
            label.appendChild(document.createTextNode(device.name ?? device.marketName));
            label.style.cursor = "pointer";
            label.classList.add("mx-2", "my-0", "p-0", "w-100");

            label.addEventListener("click", event => showDeviceInfo(device.id));

            // Add the device label to our cell.
            tdDevice.appendChild(label);

            // Add the cell to the table row.
            trDevice.appendChild(tdDevice);

            // Add the table row to the table.
            devicesTable.appendChild(trDevice);

            deviceList.push(label);
          }
        }

        const configTable = document.getElementById("configTable");
        let configOptions = [];
        let optionsList = [];

        // Update our configuration options.
        const updateConfigOptions = (newConfig) => {

          // Update our configuration.
          configOptions = newConfig;

          // Show all the valid options configured by the user.
          optionsList = configOptions.filter(x => x.match(/^(Enable|Disable)\.*/gi)).map(x => x.toUpperCase());
        };

        // Initialize our feature option configuration.
        updateConfigOptions(currentConfig[0].options ?? []);

        // Is this feature option set explicitly?
        const isOptionSet = (featureOption, deviceMac) => {

          const optionRegex = new RegExp("^(?:Enable|Disable)\\." + featureOption + (!deviceMac ? "" : "\\." + deviceMac) + "$", "gi");
          return optionsList.filter(x => optionRegex.test(x)).length ? true : false;
        };

        // Is a feature option globally enabled?
        const isGlobalOptionEnabled = (featureOption, defaultState) => {

          featureOption = featureOption.toUpperCase();

          // Test device-specific options.
          return optionsList.some(x => x === ("ENABLE." + featureOption)) ? true :
            (optionsList.some(x => x === ("DISABLE." + featureOption)) ? false : defaultState
            );
        };

        // Is a feature option enabled at the device or global level. This function does not traverse the scoping hierarchy.
        const isDeviceOptionEnabled = (featureOption, mac, defaultState) => {

          if(!mac) {

            return isGlobalOptionEnabled(featureOption, defaultState);
          }

          featureOption = featureOption.toUpperCase();
          mac = mac.toUpperCase();

          // Test device-specific options.
          return optionsList.some(x => x === ("ENABLE." + featureOption + "." + mac)) ? true :
            (optionsList.some(x => x === ("DISABLE." + featureOption + "." + mac)) ? false : defaultState
            );
        };

        // Is a value-centric feature option enabled at the device or global level. This function does not traverse the scoping hierarchy.
        const isOptionValueSet = (featureOption, deviceMac) => {

          const optionRegex = new RegExp("^Enable\\." + featureOption + (!deviceMac ? "" : "\\." + deviceMac) + "\\.([^\\.]+)$", "gi");

          return optionsList.filter(x => optionRegex.test(x)).length ? true : false;
        };

        // Get the value of a value-centric feature option.
        const getOptionValue = (featureOption, deviceMac) => {

          const optionRegex = new RegExp("^Enable\\." + featureOption + (!deviceMac ? "" : "\\." + deviceMac) + "\\.([^\\.]+)$", "gi");

          // Get the option value, if we have one.
          for(const option of optionsList) {

            const regexMatch = optionRegex.exec(option);

            if(regexMatch) {

              return regexMatch[1];
            }
          }

          return undefined;
        };

        // Is a feature option enabled at the device or global level. It does traverse the scoping hierarchy.
        const isOptionEnabled = (featureOption, deviceMac) => {

          const defaultState = featureOptionList[featureOption]?.default ?? true;

          if(deviceMac) {

            // Device level check.
            if(isDeviceOptionEnabled(featureOption, deviceMac, defaultState) !== defaultState) {

              return !defaultState;
            }

            // Controller level check.
            if(isDeviceOptionEnabled(featureOption, nvr.mac, defaultState) !== defaultState) {

              return !defaultState;
            }
          }

          // Global check.
          if(isGlobalOptionEnabled(featureOption, defaultState) !== defaultState) {

            return !defaultState;
          }

          // Return the default.
          return defaultState;
        };

        // Return the scope level of a feature option.
        const optionScope = (featureOption, deviceMac, defaultState, isOptionValue = false) => {

          // Scope priority is always: device, NVR, global.

          // If we have a value-centric feature option, our lookups are a bit different.
          if(isOptionValue) {

            if(deviceMac) {

              if(isOptionValueSet(featureOption, deviceMac)) {

                return "device";
              }

              if(isOptionValueSet(featureOption, nvr.mac)) {

                return "nvr";
              }
            }

            if(isOptionValueSet(featureOption)) {

              return "global";
            }

            return "none";
          }

          if(deviceMac) {

            // Let's see if we've set it at the device-level.
            if((isDeviceOptionEnabled(featureOption, deviceMac, defaultState) !== defaultState) || isOptionSet(featureOption, deviceMac)) {

              return "device";
            }

            // Now let's test the controller level.
            if((isDeviceOptionEnabled(featureOption, nvr.mac, defaultState) !== defaultState) || isOptionSet(featureOption, nvr.mac)) {

              return "nvr";
            }
          }

          // Finally, let's test the global level.
          if((isGlobalOptionEnabled(featureOption, defaultState) !== defaultState) || isOptionSet(featureOption)) {

            return "global";
          }

          // Option isn't set to a non-default value.
          return "none";
        };

        // Return the color hinting for a given option's scope.
        const optionScopeColor = (featureOption, deviceMac, defaultState, isOptionValue) => {

          switch(optionScope(featureOption, deviceMac, defaultState, isOptionValue)) {

            case "device":

              return "text-info";
              break;

            case "nvr":

              return "text-success";
              break;

            case "global":

              return deviceMac ? "text-warning" : "text-info";
              break;

            default:

              break;
          }

          return null;
        };

        // Show feature option information for a specific device, controller, or globally.
        const showDeviceInfo = async (deviceId) => {

          homebridge.showSpinner();

          // Update the selected device for visibility.
          deviceList.map(x => (x.name === deviceId) ? x.parentElement.classList.add("bg-info", "text-white") : x.parentElement.classList.remove("bg-info", "text-white"));

          // Populate the device information info pane.
          const ufpDevice = ufpDevices.find(x => x.id === deviceId);

          // Ensure we have a controller or device. The only time this won't be the case is when we're looking at global options.
          if(ufpDevice) {

            document.getElementById("deviceStatsHeader").style.display = "";
            document.getElementById("device_model").classList.remove("text-center");
            document.getElementById("device_model").colSpan = 1;
            document.getElementById("device_model").style.fontWeight = "normal";
            document.getElementById("device_model").innerHTML = ufpDevice.marketName ?? ufpDevice.type;
            document.getElementById("device_mac").innerHTML = ufpDevice.mac;
            document.getElementById("device_address").innerHTML = ufpDevice.host ?? (ufpDevice.modelKey === "sensor" ? "Bluetooth Device" : "None");
            document.getElementById("device_online").innerHTML = ("state" in ufpDevice) ? (ufpDevice.state.charAt(0).toUpperCase() + ufpDevice.state.slice(1).toLowerCase()) : "Connected";

            document.getElementById("deviceStatsTable").style.display = "inline-table";
          } else {

            document.getElementById("deviceStatsTable").style.display = "none";

            document.getElementById("deviceStatsHeader").style.display = "";
            document.getElementById("device_model").classList.remove("text-center");
            document.getElementById("device_model").colSpan = 1;
            document.getElementById("device_model").style.fontWeight = "normal";
            document.getElementById("device_model").innerHTML = "N/A"
            document.getElementById("device_mac").innerHTML = "N/A";
            document.getElementById("device_address").innerHTML = "N/A";
            document.getElementById("device_online").innerHTML = "N/A";
          }

          // Populate the feature options selected for this device.
          const ufpFeatures = await homebridge.request("/getOptions", { configOptions: configOptions, nvrUfp: ufpDevices[0], deviceUfp: ufpDevice });
          const optionsDevice = ufpFeatures.options;

          // Start with a clean slate.
          let newConfigTableHtml = "";
          configTable.innerHTML = "";

          // Initialize the full list of options.
          featureOptionList = {};
          featureOptionGroups = {};

          for(const category of ufpFeatures.categories) {

            // Now enumerate all the feature options for a given device and add then to the full list.
            for(const option of optionsDevice[category.name]) {

              const featureOption = category.name + (option.name.length ? ("." + option.name): "");

              // Add it to our full list.
              featureOptionList[featureOption] = option;

              // Cross reference the feature option group it belongs to, if any.
              if(option.group !== undefined) {

                const expandedGroup = category.name + (option.group.length ? ("." + option.group): "");

                // Initialize the group entry if needed.
                if(!featureOptionGroups[expandedGroup]) {

                  featureOptionGroups[expandedGroup] = [];
                }

                featureOptionGroups[expandedGroup].push(featureOption);
              }
            }
          }

          for(const category of ufpFeatures.categories) {

            // Only show feature option categories that are valid for this context.
            if(ufpDevice && (ufpDevice.modelKey !== "nvr") && !category.validFor.some(x => (x === ufpDevice.modelKey) || x === "all")) {

              continue;
            }

            const optionTable = document.createElement("table");
            const thead = document.createElement("thead");
            const tbody = document.createElement("tbody");
            const trFirst = document.createElement("tr");
            const th = document.createElement("th");

            // Set our table options.
            optionTable.classList.add("table", "table-borderless", "table-sm", "table-hover");
            th.classList.add("p-0");
            th.style.fontWeight = "bold";
            th.colSpan = 3;
            tbody.classList.add("table-bordered");

            // Add the feature option category description.
            th.appendChild(document.createTextNode(category.description +
              (!ufpDevice ? " (Global)" : (ufpDevice.modelKey === "nvr" ? " (Controller-wide)" : " (Device-specific)"))));

            // Add the table header to the row.
            trFirst.appendChild(th);

            // Add the table row to the table head.
            thead.appendChild(trFirst);

            // Finally, add the table head to the table.
            optionTable.appendChild(thead);

            // Now enumerate all the feature options for a given device.
            for(const option of optionsDevice[category.name]) {

              // Only show feature options that are valid for this device.
              if(ufpDevice && (ufpDevice.modelKey !== "nvr") && ((option.hasFeature && (!ufpDevice.featureFlags || !option.hasFeature.some(x => ufpDevice.featureFlags[x]))) ||
                (option.hasProperty && !option.hasProperty.some(x => x in ufpDevice)))) {

                continue;
              }

              // Expand the full feature option.
              const featureOption = category.name + (option.name.length ? ("." + option.name): "");

              // Create the next table row.
              const trX = document.createElement("tr");
              trX.classList.add("align-top");
              trX.id = "row-" + featureOption;

              // Create a checkbox for the option.
              const tdCheckbox = document.createElement("td");

              // Create the actual checkbox for the option.
              const checkbox = document.createElement("input");

              checkbox.type = "checkbox";
              checkbox.readOnly = false;
              checkbox.id = featureOption;
              checkbox.name = featureOption;
              checkbox.value = featureOption + (!ufpDevice ? "" : ("." + ufpDevice.mac));

              let initialValue = undefined;
              let initialScope;

              // Determine our initial option scope to show the user what's been set.
              switch(initialScope = optionScope(featureOption, ufpDevice?.mac, option.default, ("defaultValue" in option))) {

                case "global":
                case "nvr":

                  // If we're looking at the global scope, show the option value. Otherwise, we show that we're inheriting a value from the scope above.
                  if(!ufpDevice) {

                    if("defaultValue" in option) {

                      checkbox.checked = isOptionValueSet(featureOption);
                      initialValue = getOptionValue(checkbox.id);
                    } else {

                      checkbox.checked = isGlobalOptionEnabled(featureOption, option.default);
                    }

                    if(checkbox.checked) {

                      checkbox.indeterminate = false;
                    }

                  } else {

                    if("defaultValue" in option) {

                      initialValue = getOptionValue(checkbox.id, (initialScope === "nvr") ? nvr.mac : undefined);
                    }

                    checkbox.readOnly = checkbox.indeterminate = true;
                  }

                  break;

                case "device":
                case "none":
                default:

                  if("defaultValue" in option) {

                    checkbox.checked = isOptionValueSet(featureOption, ufpDevice?.mac);
                    initialValue = getOptionValue(checkbox.id, ufpDevice?.mac);
                  } else {

                    checkbox.checked = isDeviceOptionEnabled(featureOption, ufpDevice?.mac, option.default);
                  }

                  break;
              }

              checkbox.defaultChecked = option.default;
              checkbox.classList.add("mx-2");

              // Add the checkbox to the table cell.
              tdCheckbox.appendChild(checkbox);

              // Add the checkbox to the table row.
              trX.appendChild(tdCheckbox);

              const tdLabel = document.createElement("td");
              tdLabel.classList.add("w-100");
              tdLabel.colSpan = 2;

              let inputValue = null;

              // Add an input field if we have a value-centric feature option.
              if(("defaultValue" in option)) {

                const tdInput = document.createElement("td");
                tdInput.classList.add("mr-2");
                tdInput.style.width = "10%";

                inputValue = document.createElement("input");
                inputValue.type = "text";
                inputValue.value = initialValue ?? option.defaultValue;
                inputValue.size = 5;
                inputValue.readOnly = !checkbox.checked;

                // Add or remove the setting from our configuration when we've changed our state.
                inputValue.addEventListener("change", async () => {

                  // Find the option in our list and delete it if it exists.
                  const optionRegex = new RegExp("^(?:Enable|Disable)\\." + checkbox.id + (!ufpDevice ? "" : ("\\." + ufpDevice.mac)) + "\\.[^\\.]+$", "gi");
                  const newOptions = configOptions.filter(x => !optionRegex.test(x));

                  if(checkbox.checked) {

                    newOptions.push("Enable." + checkbox.value + "." + inputValue.value);
                  } else if(checkbox.indeterminate) {

                    // If we're in an indeterminate state, we need to traverse the tree to get the upstream value we're inheriting.
                    inputValue.value = (ufpDevice?.mac !== nvr.mac) ? (getOptionValue(checkbox.id, nvr.mac) ?? getOptionValue(checkbox.id)) : (getOptionValue(checkbox.id) ?? option.defaultValue);
                  } else {

                    inputValue.value = option.defaultValue;
                  }

                  // Update our configuration in Homebridge.
                  currentConfig[0].options = newOptions;
                  updateConfigOptions(newOptions);
                  await homebridge.updatePluginConfig(currentConfig);
                });

                tdInput.appendChild(inputValue);
                trX.appendChild(tdInput);
              }

              // Create a label for the checkbox with our option description.
              const labelDescription = document.createElement("label");
              labelDescription.for = checkbox.id;
              labelDescription.style.cursor = "pointer";
              labelDescription.classList.add("user-select-none", "my-0", "py-0");

              // Highlight options for the user that are different than our defaults.
              const scopeColor = optionScopeColor(featureOption, ufpDevice?.mac, option.default, ("defaultValue" in option));

              if(scopeColor) {

                labelDescription.classList.add(scopeColor);
              }

              // Add or remove the setting from our configuration when we've changed our state.
              checkbox.addEventListener("change", async () => {

                // Find the option in our list and delete it if it exists.
                const optionRegex = new RegExp("^(?:Enable|Disable)\\." + checkbox.id + (!ufpDevice ? "" : ("\\." + ufpDevice.mac)) + "$", "gi");
                const newOptions = configOptions.filter(x => !optionRegex.test(x));

                // Figure out if we've got the option set upstream.
                let upstreamOption = false;

                // We explicitly want to check for the scope of the feature option above where we are now, so we can appropriately determine what we should show.
                switch(optionScope(checkbox.id, (ufpDevice && (ufpDevice.mac !== nvr.mac)) ? nvr.mac : null, option.default, ("defaultValue" in option))) {

                  case "device":
                  case "nvr":

                    if(ufpDevice.mac !== nvr.mac) {

                      upstreamOption = true;
                    }

                    break;

                  case "global":

                    if(ufpDevice) {

                      upstreamOption = true;
                    }

                    break;

                  default:

                    break;
                }

                // For value-centric feature options, if there's an upstream value assigned above us, we don't allow for an unchecked state as it makes no sense in that context.
                if(checkbox.readOnly && (!("defaultValue" in option) || (("defaultValue" in option) && inputValue && !upstreamOption))) {

                  // We're truly unchecked. We need this because a checkbox can be in both an unchecked and indeterminate simultaneously,
                  // so we use the readOnly property to let us know that we've just cycled from an indeterminate state.
                  checkbox.checked = checkbox.readOnly = false;
                } else if(!checkbox.checked) {

                  // If we have an upstream option configured, we reveal a third state to show inheritance of that option and allow the user to select it.
                  if(upstreamOption) {

                    // We want to set the readOnly property as well, since it will survive a user interaction when they click the checkbox to clear out the
                    // indeterminate state. This allows us to effectively cycle between three states.
                    checkbox.readOnly = checkbox.indeterminate = true;
                  }

                  if(("defaultValue" in option) && inputValue) {

                    inputValue.readOnly = true;
                  }
                } else if(checkbox.checked) {

                  // We've explicitly checked this option.
                  checkbox.readOnly = checkbox.indeterminate = false;

                  if(("defaultValue" in option) && inputValue) {

                    inputValue.readOnly = false;
                  }
                }

                // The setting is different from the default, highlight it for the user, accounting for upstream scope, and add it to our configuration.
                if(!checkbox.indeterminate && ((checkbox.checked !== option.default) || upstreamOption)) {

                  labelDescription.classList.add("text-info");
                  newOptions.push((checkbox.checked ? "Enable." : "Disable.") + checkbox.value);
                } else {

                  // We've reset to the defaults, remove our highlighting.
                  labelDescription.classList.remove("text-info");
                }

                // Update our Homebridge configuration.
                if(("defaultValue" in option) && inputValue) {

                  // Inform our value-centric feature option to update Homebridge.
                  const changeEvent = new Event("change");

                  inputValue.dispatchEvent(changeEvent);
                } else {

                  // Update our configuration in Homebridge.
                  currentConfig[0].options = newOptions;
                  updateConfigOptions(newOptions);
                  await homebridge.updatePluginConfig(currentConfig);
                }

                // If we've reset to defaults, make sure our color coding for scope is reflected.
                if((checkbox.checked === option.default) || checkbox.indeterminate) {

                  const scopeColor = optionScopeColor(featureOption, ufpDevice?.mac, option.default, ("defaultValue" in option));

                  if(scopeColor) {

                    labelDescription.classList.add(scopeColor);
                  }
                }

                // Adjust visibility of other feature options that depend on us.
                if(featureOptionGroups[checkbox.id]) {

                  const entryVisibility = isOptionEnabled(featureOption, ufpDevice?.mac) ? "" : "none";

                  // Lookup each feature option setting and set the visibility accordingly.
                  for(const entry of featureOptionGroups[checkbox.id]) {

                    document.getElementById("row-" + entry).style.display = entryVisibility;
                  }
                }
              });

              // Add the actual description for the option after the checkbox.
              labelDescription.appendChild(document.createTextNode(option.description));

              // Add the label to the table cell.
              tdLabel.appendChild(labelDescription);

              // Provide a cell-wide target to click on options.
              tdLabel.addEventListener("click", () => checkbox.click());

              // Add the label table cell to the table row.
              trX.appendChild(tdLabel);

              // Adjust the visibility of the feature option, if it's logically grouped.
              if((option.group !== undefined) && !isOptionEnabled(category.name + (option.group.length ? ("." + option.group): ""), ufpDevice?.mac)) {

                trX.style.display = "none";
              }

              // Add the table row to the table body.
              tbody.appendChild(trX);
            }

            // Add the table body to the table.
            optionTable.appendChild(tbody);

            // Add the table to the page.
            configTable.appendChild(optionTable);
          }

          homebridge.hideSpinner();
        }

        // Display the feature options to the user.
        showDeviceInfo(controller ? ufpDevices[0].id : null);

        // All done. Let the user interact with us.
        homebridge.hideSpinner();
      };

      // Show the support tab.
      const showSupport = () => {

        // Show the beachball while we setup.
        homebridge.showSpinner();
        homebridge.hideSchemaForm();

        // Create our UI.
        document.getElementById("menuHome").classList.add("btn-elegant");
        document.getElementById("menuHome").classList.remove("btn-primary");
        document.getElementById("menuProtect").classList.remove("btn-elegant");
        document.getElementById("menuProtect").classList.add("btn-primary");
        document.getElementById("menuSettings").classList.remove("btn-elegant");
        document.getElementById("menuSettings").classList.add("btn-primary");

        document.getElementById("pageSupport").style.display = "block";
        document.getElementById("pageOptions").style.display = "none";

        // All done. Let the user interact with us.
        homebridge.hideSpinner();
      };

      // Show the main plugin configuration tab.
      const showSettings = () => {

        // Show the beachball while we setup.
        homebridge.showSpinner();

        // Create our UI.
        document.getElementById("menuHome").classList.remove("btn-elegant");
        document.getElementById("menuHome").classList.add("btn-primary");
        document.getElementById("menuProtect").classList.remove("btn-elegant");
        document.getElementById("menuProtect").classList.add("btn-primary");
        document.getElementById("menuSettings").classList.add("btn-elegant");
        document.getElementById("menuSettings").classList.remove("btn-primary");

        document.getElementById("pageSupport").style.display = "none";
        document.getElementById("pageOptions").style.display = "none";

        homebridge.showSchemaForm();

        // All done. Let the user interact with us.
        homebridge.hideSpinner();
      };

      // Show a disabled interface.
      const showDisabledBanner = () => {

        document.getElementById("disabledBanner").style.display = "block";
      };

      // Toggle our enabled state.
      const enablePlugin = async () => {

        // Show the beachball while we setup.
        homebridge.showSpinner();

        // Create our UI.
        document.getElementById("disabledBanner").style.display = "none";
        currentConfig[0].disablePlugin = false;

        await homebridge.updatePluginConfig(currentConfig)
        await homebridge.savePluginConfig()

        // All done. Let the user interact with us.
        homebridge.hideSpinner()
      };

      // Add our event listeners to animate the UI.
      menuHome.addEventListener("click", () => showSupport());
      menuProtect.addEventListener("click", () => showControllers());
      menuSettings.addEventListener("click", () => showSettings());
      disabledEnable.addEventListener("click", () => enablePlugin());

      if(currentConfig.length) {

        document.getElementById("menuWrapper").style.display = "inline-flex"
        showSettings();

        // If the plugin's disabled, inform the user.
        if(currentConfig[0].disablePlugin) {

          showDisabledBanner();
        }
      } else {

        currentConfig.push({ name: "UniFi Protect" });
        await homebridge.updatePluginConfig(currentConfig);
        showIntro();
      }
    } catch (err) {

      // If we had an error instantiating or updating the UI, notify the user.
      homebridge.toast.error(err.message, "Error");
    } finally {

      // Always leave the UI in a usable place for the end user.
      homebridge.hideSpinner();
    }
  })();
</script>
